
// actions index.js

import ApolloClient from 'apollo-boost';

import gql from 'graphql-tag';

import Swal from 'sweetalert2';

const API_URL = 'http://localhost:3001/graphql/';
const client = new ApolloClient({
   uri: API_URL
});

// LOAD CONTACTS START

export const loadContactsSuccess = (phones) => ({
   type: 'LOAD_CONTACT_SUCCESS',
   phones
})

export const loadContactsFailure = () => ({
   type: 'LOAD_CONTACT_FAILURE'
})

export const loadContacts = (offset = 0, limit = 5) => {

   const phonesQuery = gql`
   query{
      phones(pagination:{offset: ${offset}, limit:${limit}}){
         count
         items{
            id
            name
            phone
         }
      }
   }`;
   return dispatch => {
      return client.query({
         query: phonesQuery
      })
         .then(function (response) {
            dispatch(loadContactsSuccess(response.data.phones))
         })
         .catch(function (error) {
            console.log(error);
            dispatch(loadContactsFailure())
         })
   }
}

//LOAD CONTACTS END


//SEARCH CONTACTS START

export const searchContacts = (name, phone, offset = 0, limit = 5) => {

   const searchQuery = gql`
   query 
      phones(
         $name : String!, 
         $phone: String!
         $offset : Int!
         $limit : Int!
      ){
         phones(
         name : $name,
         phone: $phone,
         pagination : {
            offset : $offset,
            limit : $limit
         }
         ){
         count
         items{
            id
            name
            phone
         }
      }
   }`;

   return dispatch => {
      return client.query({
         query: searchQuery,
         variables: {
            name,
            phone,
            offset,
            limit
         }
      })
         .then(function (response) {
            dispatch(loadContactsSuccess(response.data.phones))
         })
         .catch(function (error) {
            console.log(error);
            dispatch(loadContactsFailure)
         })
   }

}

//SEARCH CONTACTS END


//ON SEARCH

export const onSearch = (filter) => ({
   type: 'ON_SEARCH',
   filter
})

//PAGINATION ACTIONS START

export const previousPage = () => ({
   type: 'PREVIOUS_PAGE'
})

export const changePage = (page) => ({
   type: 'CHANGE_PAGE',
   page
})

export const nextPage = () => ({
   type: 'NEXT_PAGE'
})

//PAGINATION ACTIONS END



//START POST CONTATCTS

const postContactSuccess = (contact) => ({
   type: 'POST_CONTACT_SUCCESS',
   contact
})

const postContactFailure = (id) => ({
   type: 'POST_CONTACT_FAILURE',
   id
})

const postContactRedux = (id, name, phone) => ({
   type: 'POST_CONTACT',
   id, name, phone
})

export const postContact = (name, phone) => {
   const id = new Date().getTime();
   const addQuery = gql`
        mutation addContact($id: ID!, $name: String!, $phone: String!) {
            addContact(id: $id, name: $name, phone: $phone) {
                id
                name
                phone
            }
        }`;

   return dispatch => {
      dispatch(postContactRedux(id, name, phone));

      return client.mutate({
         mutation: addQuery,
         variables: {
            id,
            name,
            phone
         }
      })
         .then(function (response) {
            Swal.fire({
               position: 'center',
               icon: 'success',
               title: 'Contact added successfully!',
               showConfirmButton: false,
               timer: 1200
            })
            dispatch(postContactSuccess(response.data.addContact))
         })
         .catch(function (error) {
            Swal.fire({
               icon: 'error',
               title: 'Oops...',
               text: 'Something went wrong! check your connection',
               showConfirmButton: true
            })
            dispatch(postContactFailure(id))
         })
   }

}

//POST CONTATCTS END



//START RESEND CONTACT

export const resendContact = (id, name, phone) => {
   const addQuery = gql`
        mutation addContact($id: ID!, $name: String!, $phone: String!) {
            addContact(id: $id, name: $name, phone: $phone) {
                id
                name
                phone
            }
        }`;
   return dispatch => {
      return client.mutate({
         mutation: addQuery,
         variables: {
            id,
            name,
            phone
         }
      })
         .then(function (response) {
            Swal.fire({
               position: 'center',
               icon: 'success',
               title: 'Contact added successfully!',
               showConfirmButton: false,
               timer: 1000
            })
            dispatch(postContactSuccess(response.data.addContact))
         })
         .catch(function (error) {
            Swal.fire({
               icon: 'error',
               title: 'There is a problem',
               text: 'Something went wrong! check your connection',
               showConfirmButton: true
            })
            dispatch(postContactFailure(id))
         })
   }
}

//RESEND CONTACT END



//START DELETE CONTACT 

export const deleteContactRedux = (id) => ({
   type: 'DELETE_CONTACT', id
})

const deleteContactSuccess = (id) => ({
   type: 'DELETE_CONTACT_SUCCESS', id
})

const deleteContactFailure = () => ({
   type: 'DELETE_CONTACT_FAILURE'
})

export const deleteContact = (id) => {
   const deleteQuery = gql`
   mutation deleteContact($id: ID!){
      deleteContact(id: $id){
         id
      }
   }`;
   return dispatch => {
      Swal.fire({
         icon: 'warning',
         title: "Are you sure delete this Contact?",
         text: "You can't revert this action",
         type: "warning",
         showCancelButton: true,
         confirmButtonText: "Yes Delete it!",
         cancelButtonText: "No, Keep it!",
         showCloseButton: true,
         showLoaderOnConfirm: true
      }).then(result => {
         if (result.value) {
            dispatch(deleteContactRedux(id));
            return client.mutate({
               mutation: deleteQuery,
               variables: {
                  id
               }
            })
               .then(function (response) {
                  dispatch(deleteContactSuccess(response))
               })
               .catch(function (error) {
                  dispatch(deleteContactFailure())

               })
         }
      })
   }
}

//START DELETE CONTACT



//START EDIT CONTACT DATA

export const onUpdateContact = (id) => ({
   type: 'ON_UPDATE_CONTACT',
   id
})

export const offUpdateContact = (id) => ({
   type: 'OFF_UPDATE_CONTACT',
   id
})

const updateContactSuccess = (contact) => ({
   type: 'UPDATE_CONTACT_SUCCESS',
   contact
})

const updateContactFailure = (id) => ({
   type: 'UPDATE_CONTACT_FAILURE',
   id
})

const updateContactRedux = (id, name, phone) => ({
   type: 'UPDATE_CONTACT', 
   id,
   name,
   phone
})

export const updateContact = (id, name, phone) => {
   return dispatch => {
      dispatch(updateContactRedux(id, name, phone));
      const updateQuery = gql`
      mutation updateContact($id: ID!, $name: String!, $phone: String!) {
        updateContact(id: $id, name: $name, phone: $phone ) {
          id
          name
          phone
        }
      }
    `;

      return client.mutate({
         mutation: updateQuery,
         variables: {
            id,
            name,
            phone
         }
      })
         .then(function (response) {
            Swal.fire({
               position: 'center',
               icon: 'success',
               title: 'Contact updated successfully!',
               showConfirmButton: false,
               timer: 1200
            })
            dispatch(updateContactSuccess(response.data.updateContact))
         })
         .catch(function (error) {
            Swal.fire({
               icon: 'error',
               title: 'There is a problem',
               text: 'Something went wrong! check your connection',
               showConfirmButton: true
            })
            dispatch(updateContactFailure(id))
         });
   }
}

//EDIT CONTACT DATA END

// components Contacts.js

import React from 'react';

const Contact = (props) => {
    return (
        <tr>
            <td >{props.index}</td>
            <td >{props.name}</td>
            <td >{props.phone}</td>

            <td >

            <button type="button" className="btn btn-success" onClick={props.onUpdateContact}><i className="fas fa-pencil-alt"></i> Edit </button>

                {props.sent ?
                    (<button type="button" className="btn btn-danger" onClick={props.onDelete}><i className="fas fa-trash"></i> Delete</button>) : (<button type="submit" className="btn btn-info" onClick={props.onResend}><i className="fas fa-sync-alt"></i>Resend</button>)
                }

            </td>

        </tr>
    )
}

export default Contact;

//components HeaderCard.js

import React  from 'react';
import Clock from 'react-live-clock';

function HeaderCard() {

    return (

        <div className="card-header text-center font-weight-bold">
            <h1> Phone Book Apps</h1>
            <Clock format={'MMMM Mo YYYY, HH:mm:ss'} ticking={true} timezone={'Asia/Jakarta'} style={{ fontSize: '20px' }} />
        </div>

    )

}

export default HeaderCard;

// components PhoneBox.js
import React from 'react';
import ListContacts from '../containers/ListContacts';
import SearchForm from '../containers/SearchForm';
import Pagination from '../containers/Pagination';
import AddForm from '../containers/AddForm';
import HeaderCard from './HeaderCard';

function PhoneBox() {
  return (
    <div className="container">
      <div className="card bg-light">
        <HeaderCard />
        <div className="card-body">
          <ListContacts />
          <SearchForm />
          <Pagination />
          <AddForm />
        </div>
        <div className="card-footer text-center font-weight-bold">
          
        </div>
      </div>
    </div>
  )
}

export default PhoneBox;

//containers AddForm.js

import React, { Component } from 'react';

import { connect } from 'react-redux';

import { postContact } from '../actions';

class AddForm extends Component {

    constructor(props) {
        super(props);
        this.state = {
            name: '',
            phone: ''
        }
        this.handleChange = this.handleChange.bind(this);

        this.handleSubmit = this.handleSubmit.bind(this);
        
        this.handleCancel = this.handleCancel.bind(this);
    }

    handleChange(event) {
        this.setState({ [event.target.name]: event.target.value });
    }

    handleSubmit(event) {
        event.preventDefault();
        if (this.state.name && this.state.phone) {
            this.props.postContact(this.state.name, this.state.phone);
            this.setState({ name: '', phone: '' });
        } else {

            // swall Post Contact

        }
    }

    handleCancel(event) {
        event.preventDefault();
        this.setState({ name: '', phone: '' })
        let collapseAdd = document.getElementById('btn-collapse');
        collapseAdd.click();
    }

    render() {
        return (
            <div>
                <button id="btn-collapse" className="btn btn-primary btn-lg ml-3 mb-3 d-flex" type="button" data-toggle="collapse" data-target="#add-collapse" aria-expanded="false" aria-controls="add-collapse">
                    Add New Contact
            </button>

                <div className="collapse mb-3" id="add-collapse">

                    <div className="card card-body">
                        <form onSubmit={this.handleSubmit}>
                            <div className="form-group">
                                <div className="row">
                                    <div className="col">
                                        <label><b>Name</b></label>
                                        <input
                                            type="text"
                                            name="name"
                                            className="form-control"
                                            placeholder="Input contact name..."
                                            value={this.state.name}
                                            required={true}
                                            onChange={this.handleChange}
                                        />
                                    </div>

                                    <div className="col">
                                        <label><b>Phone</b></label>
                                        <input
                                            type="text"
                                            name="phone"
                                            placeholder="input phone number..."
                                            value={this.state.phone}
                                            className="form-control"
                                            required={true}
                                            onChange={this.handleChange}
                                        />
                                    </div>
                                </div>
                            </div>

                            <div className="row d-flex justify-content-end" >

                                <button type="submit" className="btn btn-success d-flex">
                                    <i className="fas fa-plus"> Save</i>
                                </button>

                                <button type="submit" className="btn btn-warning d-flex ml-2 mr-3" onClick={this.handleCancel}>
                                    <i className="fas fa-ban"> Cancel</i>
                                </button>

                            </div>
                        </form>

                    </div>
                </div>
            </div >
        )
    }
}

const mapDispatchToProps = dispatch => ({
    postContact: (name, phone) => dispatch(postContact(name, phone))
})

export default connect(
    null,
    mapDispatchToProps
)(AddForm)

// containers ContactActive.js

import { connect } from 'react-redux'

import { resendContact, deleteContact, onUpdateContact } from '../actions';

import Contact from '../components/Contact'

const mapDispatchToProps = (dispatch, ownProps) => ({
  onDelete: () => dispatch(deleteContact(ownProps.id)),
  onResend: () => dispatch(resendContact(ownProps.id, ownProps.name, ownProps.phone)),

  onUpdateContact: () => dispatch(onUpdateContact(ownProps.id))
})

export default connect(
  null,
  mapDispatchToProps
)(Contact)

// containers EditForm.js

import React, { Component } from 'react';

import { connect } from 'react-redux';

import { offUpdateContact, updateContact } from '../actions';

class EditForm extends Component {

    constructor(props) {
        super(props);
        this.state = {
            name: this.props.name,
            phone: this.props.phone
        }
        this.handleChange = this.handleChange.bind(this);

        this.handleSubmit = this.handleSubmit.bind(this);

        this.handleCancel = this.handleCancel.bind(this);
    }

    handleChange(event) {
        this.setState({ [event.target.name]: event.target.value });
    }

    handleSubmit(event) {
        event.preventDefault();
        console.log('Submit Button');
        if (this.state.name && this.state.phone) {
            this.props.updateContact(this.state.name, this.state.phone);
        } else {

            // swall Edit Contact

        }
    }

    handleCancel(event) {
        console.log('Cancel Button');
        this.setState({
            name: this.props.name,
            phone: this.props.phone
        })
        this.props.offUpdateContact()
    }

    render() {
        return (
            <tr>
                <div className="col-md-10 ">
                    <th scope="row">{this.props.index}</th>
                </div>

                <td>
                    <div className="col-md-8 ">
                        <form className="form-row" onSubmit={this.handleSubmit}>
                            <input type="text" className="form-control" name="name" value={this.state.name} onChange={this.handleChange} required={true} />
                        </form>
                    </div>
                </td>

                <td>
                <div className="col-md-8 ">
                        <form className="form-row" onSubmit={this.handleSubmit}>
                            <input type="text" className="form-control" name="phone" value={this.state.phone} onChange={this.handleChange} required={true} />
                        </form>
                    </div>
                </td>

                <td>
                    <button type="submit" className="btn btn-success  mr-2" onClick={this.handleSubmit}><i className="fas fa-check"></i> Save</button>

                    <button type="button" className="btn btn-warning " onClick={this.handleCancel}><i className="fas fa-times"></i> Cancel</button>
                </td>
            </tr>

        )
    }
}

const mapDispatchToProps = (dispatch, ownProps ) => ({
    offUpdateContact: () => dispatch(offUpdateContact(ownProps.id)),
    updateContact: (name, phone) => dispatch(updateContact(ownProps.id, name, phone))
})

export default connect(
    null,
    mapDispatchToProps
)(EditForm)

// containers ListContacs.js

import React, { Component } from 'react';

import Contact from './ContactActive'

import { connect } from 'react-redux';

import { loadContacts } from '../actions';

import EditForm from '../containers/EditForm'

class ContactList extends Component {

  componentDidMount() {
    this.props.loadContacts();
  }

  render() {
    const nodes = this.props.contacts.map((item, index) => {
      return item.isEditing ?
        (
          <EditForm
            key={index}
            index={this.props.page === 1 ? index + 1 : (this.props.page - 1) * 5 + (index + 1)}
            id={item.id}
            name={item.name}
            phone={item.phone}
            sent={item.sent}
            edit={item.isEditing}
          />
        )
        : (
          <Contact
            key={index}
            index={this.props.page === 1 ? index + 1 : (this.props.page - 1) * 5 + (index + 1)}
            id={item.id}
            name={item.name}
            phone={item.phone}
            sent={item.sent}
            edit={item.isEditing}
          />
        )
    })

    return (
      <div className="contact-list" style={{ fontFamily: "Roboto" }}>

        <table className="table">
          <thead className="thead-dark" style={{ fontSize: "19px" }}>
            <tr>
              <th scope="col">#</th>
              <th scope="col">Name</th>
              <th scope="col">Phone</th>
              <th scope="col">Actions</th>
            </tr>
          </thead>
          <tbody>
            {nodes}
          </tbody>
        </table>

      </div >
    )
  }
}

const mapStateToProps = (state) => ({
  contacts: state.contacts.contacts,
  page: state.contacts.page,
  pages: state.contacts.pages
})

const mapDispatchToProps = (dispatch) => ({
  loadContacts: () => dispatch(loadContacts())
})

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(ContactList)

//containers Pagination.js

import React, { Component } from 'react';
import { connect } from 'react-redux';
import { loadContacts, nextPage, previousPage, changePage, searchContacts } from '../actions';

class Pagination extends Component {
   constructor(props) {

      super(props);
      this.state = {
         limit: 5
      }
      this.handlePrevious = this.handlePrevious.bind(this);

      this.handleNext = this.handleNext.bind(this);
     
      this.handlePage = this.handlePage.bind(this);
   }

   handlePrevious(event) {
      const { limit } = this.state;
      let offset = ((this.props.page - 1) - 1) * limit

      if (this.props.isSearch) {
         this.props.searchContacts(this.props.filterName, this.props.filterPhone, offset, limit);
      } else {
         this.props.loadContacts(offset);
      }
      this.props.previousPage();
      event.preventDefault();
   }

   handleNext(event) {
      const { limit } = this.state;
      let offset = ((this.props.page + 1) - 1) * limit;

      if (this.props.isSearch) {
         this.props.searchContacts(this.props.filterName, this.props.filterPhone, offset, limit);
      } else {
         this.props.loadContacts(offset);
      }
      this.props.nextPage();
      event.preventDefault();
   }

   handlePage(event) {
      const { limit } = this.state;
      const page = parseInt(event.target.id);
      const offset = (page - 1) * this.state.limit;

      if (this.props.isSearch) {
         this.props.searchContacts(this.props.filterName, this.props.filterPhone, offset, limit);
      } else {
         this.props.loadContacts(offset);
      }
      this.props.changePage(page);
      event.preventDefault();
   }

   render() {
      return (
         <nav aria-label="Page navigation example" >
            <ul className="pagination justify-content-center">

               <li className={this.props.page === 1 ? "page-item disabled" : "page-item"}>
                  <a className="page-link" href="/#" onClick={this.handlePrevious}>Previous</a>
               </li>

               {[...Array(this.props.pages)].map((num, index) => {
                  return (<li className={this.props.page === index + 1 ? "page-item active" : "page-item"} key={index} ><a 
                  className="page-link" id={index + 1} onClick={this.handlePage} href="/#" >{index + 1}</a></li>)
               })
               }

               <li className={this.props.page === this.props.pages ? "page-item disabled" : "page-item"}>
                  <a className="page-link" href="/#" onClick={this.handleNext}>Next</a>
               </li>

            </ul>
         </nav >
      )
   }
}

const mapStateToProps = (state) => ({
   page: state.contacts.page,
   pages: state.contacts.pages,
   isSearch: state.contacts.isSearch,
   filterName: state.contacts.filterName,
   filterPhone: state.contacts.filterPhone
})

const mapDispatchToProps = dispatch => ({
   loadContacts: (offset, limit) => dispatch(loadContacts(offset, limit)),
   searchContacts: (name, phone, offset, limit) => (dispatch(searchContacts(name, phone, offset, limit))),
   changePage: (page) => dispatch(changePage(page)),
   nextPage: () => dispatch(nextPage()),
   previousPage: () => dispatch(previousPage())
})

export default connect(
   mapStateToProps,
   mapDispatchToProps
)(Pagination)

// containers SearchForm.js

import React, { Component } from 'react';

import { connect } from 'react-redux';

import { searchContacts, loadContacts, onSearch } from '../actions';

class SearchForm extends Component {

    constructor(props) {
        super(props);
        this.state = {
            name: '',
            phone: ''
        }

        this.handleChangeName = this.handleChangeName.bind(this);

        this.handleChangePhone = this.handleChangePhone.bind(this);

        this.handleReset = this.handleReset.bind(this);
    }

    handleChangeName(event) {
        let { phone } = this.state
        
        this.setState({ name: event.target.value })
        this.props.searchContacts(event.target.value, phone)
        this.props.onSearch({ name: event.target.value, phone: phone })
    }

    handleChangePhone(event) {
        let { name } = this.state

        this.setState({ phone: event.target.value })
        this.props.searchContacts(name, event.target.value)
        this.props.onSearch({ name: name, phone: event.target.value })
    }

    handleReset(event) {
        this.props.loadContacts()
        this.setState({ name: '', phone: '' });
        event.preventDefault();
    }

    render() {
        return (

            <div className="card mb-3">
                <div className="card-header" style={{ fontSize: "23px" }}>
                    Search Contact
                 <i className="fas fa-search ml-3"></i>
                </div>

                <div className="card-body">
                    <form>
                        <div className="form-group row">
                            <label className="col-sm-1 col-form-label">
                                <b>Name</b>
                            </label>
                            <div className="col-sm-4">
                                <input
                                    type="text"
                                    className="form-control"
                                    placeholder="Search by name.."
                                    value={this.state.name}
                                    onChange={this.handleChangeName}
                                    name="name"
                                />
                            </div>
                            
                            <label className="col-sm-1 col-form-label">
                                <b>Phone</b>
                            </label>
                            <div className="col-sm-4">
                                <input
                                    type="text"
                                    placeholder="Search by phone.."
                                    className="form-control"
                                    value={this.state.phone}
                                    onChange={this.handleChangePhone}
                                    name="phone"
                                />
                            </div>

                            <div className="col-md-2">
                                <button className="btn btn-info" onClick={this.handleReset}><i className="fas fa-sync-alt"></i> Reset</button>
                            </div>

                        </div>
                    </form>
                </div>
            </div >
        )
    }
}

const mapStateToProps = (state) => ({
    isSearch: state.contacts.isSearch,
    filterName: state.contacts.filterName,
    filterPhone: state.contacts.filterPhone
})

const mapDispatchToProps = dispatch => ({
    searchContacts: (name, phone, offset, limit) => dispatch(searchContacts(name, phone, offset = 0, limit = 5)),
    loadContacts: () => dispatch(loadContacts()),
    onSearch: (filter) => dispatch(onSearch(filter))
})

export default connect(
    mapStateToProps,
    mapDispatchToProps
)(SearchForm)



// reducers contact.js

const initState = {
    contacts: [],
    page: 1,
    pages: 0,
    isSearch: false,
    filtername: '',
    filterPhone: ''
  }
  
  const contacts = (state = initState, action) => {
    switch (action.type) {
  
      case 'LOAD_CONTACT_SUCCESS':
        return {
          ...state,
          contacts: action.phones.items.map((item) => {
            item.sent = true;
            return item
          }),
          pages: Math.ceil(action.phones.count / 5)
        }
  
  
  
      case 'ON_SEARCH':
        return {
          ...state,
          isSearch: true,
          filtername: action.filter.name,
          filterPhone: action.filter.phone
        }
  
  
  
      case 'NEXT_PAGE':
        return {
          ...state,
          page: state.page + 1
        }
  
  
      case 'PREVIOUS_PAGE':
        return {
          ...state,
          page: state.page - 1
        }
  
  
      case 'CHANGE_PAGE':
        return {
          ...state,
          page: action.page
        }
  
  
  
      case 'POST_CONTACT':
        return {
          ...state,
          contacts: [
            ...state.contacts,
            {
              id: action.id,
              name: action.name,
              phone: action.phone,
              sent: true
            }
          ]
        }
  
      case 'POST_CONTACT_SUCCESS':
        return {
          ...state,
          contacts: state.contacts.map(item => {
            item.sent = true;
            return item
          })
        }
  
      case 'POST_CONTACT_FAILURE':
        return {
          ...state,
          contacts: state.contacts.map((item) => {
            if (item.id === action.id) {
              item.sent = false;
            }
            return item
          })
        }
  
  
  
      case 'ON_UPDATE_CONTACT':
        return {
          ...state,
          contacts: state.contacts.map((item) => {
            if (item.id === action.id) {
              item.isEditing = true;
            }
            return item
          })
        }
  
      case 'OFF_UPDATE_CONTACT':
        return {
          ...state,
          contacts: state.contacts.map((item) => {
            if (item.id === action.id) {
              item.isEditing = false;
            }
            return item
          })
        }
  
      case 'UPDATE_CONTACT':
        return {
          ...state,
          contacts: state.contacts.map(item => {
            if (item.id === action.id) {
              item.name = action.name;
              item.phone = action.phone;
            }
            return item
          })
        }
  
      case 'UPDATE_CONTACT_SUCCESS':
        return {
          ...state,
          contacts: state.contacts.map(item => {
            item.sent = true;
            item.isEditing = false;
            return item
          })
        }
  
      case 'UPDATE_CONTACT_FAILURE':
        return {
          ...state,
          contacts: state.contacts.map((item) => {
            if (item.id === action.id) {
              item.sent = false;
            }
            return item
          })
        }
  
  
  
  
      case 'DELETE_CONTACT':
        return {
          ...state,
          contacts: state.contacts.filter((item) => item.id !== action.id)
        }
  
      case 'DELETE_CONTACT_SUCCES':
        return state
  
      case 'LOAD_CONTACT_FAILURE':
      case 'DELETE_CONTACT_FAILURE':
      default:
        return state
    }
  }
  
  export default contacts
  
 // reducers index.js

 import { combineReducers } from 'redux';

import contacts from './contacts';

export default combineReducers({
    contacts
})
































































































































